// Generated automatically by nearley, version 2.20.1
// http://github.com/Hardmath123/nearley
(function () {
function id(x) { return x[0]; }

	// const { lexer } = require("../lexer");
	const t = require("./transform");

	const nm = require("nearley-moo");
	const { tokens } = require("../lexer/tokens");
	
	nm(tokens);

	/*const keys = Array.from(Reflect.ownKeys(global))
					.filter(x => typeof x === "string");

	console.log(keys);*/
var grammar = {
    Lexer: undefined,
    ParserRules: [
    {"name": "func_call", "symbols": ["value_expr", "func_args"], "postprocess": data => ({ type: "func_call", func: t.first(data), args: t.last(data), })},
    {"name": "func_args", "symbols": [lparen, "_", "arg_list", "_", rparen], "postprocess": t.mid},
    {"name": "arg_list", "symbols": [], "postprocess": () => ({ type: "arg_list", args: [] })},
    {"name": "arg_list$ebnf$1", "symbols": []},
    {"name": "arg_list$ebnf$1$subexpression$1", "symbols": ["_", comma, "__nl", "value_expr"]},
    {"name": "arg_list$ebnf$1", "symbols": ["arg_list$ebnf$1", "arg_list$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "arg_list$ebnf$2$subexpression$1", "symbols": ["_", comma, "__nl"]},
    {"name": "arg_list$ebnf$2", "symbols": ["arg_list$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "arg_list$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "arg_list", "symbols": ["value_expr", "arg_list$ebnf$1", "arg_list$ebnf$2"], "postprocess": data => ({ type: "arg_list", args: [t.first(data), ...t.second(data).map(t.last)] })},
    {"name": "ufc", "symbols": ["value_expr", ufc, "func_call"], "postprocess": data => ({ type: "ufc", caller: t.first(data), call: t.last(data) })},
    {"name": "method_call", "symbols": ["value_expr", dot, "ident", "func_args"], "postprocess": data => ({ type: "method_call", object: t.first(data), method: t.beforeLast(data), args: t.last(data) })},
    {"name": "method_call", "symbols": ["value_expr", lbracket, "_nl", "value_expr", "_nl", rbracket, "func_args"], "postprocess": data => ({ type: "method_call", object: t.first(data), method: data[3], args: t.last(data) })},
    {"name": "operation", "symbols": ["assign_expr"], "postprocess": id},
    {"name": "operation", "symbols": ["sum_expr"], "postprocess": id},
    {"name": "operation", "symbols": ["logical_expr"], "postprocess": id},
    {"name": "operation", "symbols": ["spe_expr"], "postprocess": id},
    {"name": "assign_expr", "symbols": ["fully_qualified_name", "__nl", assign, "__", "value_expr"], "postprocess": t.binaryOp("assign")},
    {"name": "assign_expr", "symbols": ["fully_qualified_name", "__nl", plus_eq, "__", "value_expr"], "postprocess": t.binaryOp("plus_eq")},
    {"name": "assign_expr", "symbols": ["fully_qualified_name", "__nl", minus_eq, "__", "value_expr"], "postprocess": t.binaryOp("minus_eq")},
    {"name": "assign_expr", "symbols": ["fully_qualified_name", "__nl", times_eq, "__", "value_expr"], "postprocess": t.binaryOp("times_eq")},
    {"name": "assign_expr", "symbols": ["fully_qualified_name", "__nl", div_eq, "__", "value_expr"], "postprocess": t.binaryOp("div_eq")},
    {"name": "assign_expr", "symbols": ["fully_qualified_name", "__nl", mod_eq, "__", "value_expr"], "postprocess": t.binaryOp("mod_eq")},
    {"name": "assign_expr", "symbols": ["fully_qualified_name", "__nl", bitwise_and_eq, "__", "value_expr"], "postprocess": t.binaryOp("bitwise_and_eq")},
    {"name": "assign_expr", "symbols": ["fully_qualified_name", "__nl", bitwise_or_eq, "__", "value_expr"], "postprocess": t.binaryOp("bitwise_or_eq")},
    {"name": "assign_expr", "symbols": ["fully_qualified_name", "__nl", bitwise_xor_eq, "__", "value_expr"], "postprocess": t.binaryOp("bitwise_xor_eq")},
    {"name": "assign_expr", "symbols": ["fully_qualified_name", "__nl", land_eq, "__", "value_expr"], "postprocess": t.binaryOp("land_eq")},
    {"name": "assign_expr", "symbols": ["fully_qualified_name", "__nl", lor_eq, "__", "value_expr"], "postprocess": t.binaryOp("lor_eq")},
    {"name": "assign_expr", "symbols": [unary_neg_eq, "fully_qualified_name"], "postprocess": t.unaryOp("unary_neg_eq")},
    {"name": "sum_expr", "symbols": ["mult_expr", "__nl", plus, "__", "sum_expr"], "postprocess": t.binaryOp("plus")},
    {"name": "sum_expr", "symbols": ["mult_expr", "__nl", minus, "__", "sum_expr"], "postprocess": t.binaryOp("minus")},
    {"name": "sum_expr", "symbols": ["mult_expr"], "postprocess": id},
    {"name": "mult_expr", "symbols": ["pow_expr", "__nl", times, "__", "mult_expr"], "postprocess": t.binaryOp("times")},
    {"name": "mult_expr", "symbols": ["pow_expr", "__nl", div, "__", "mult_expr"], "postprocess": t.binaryOp("div")},
    {"name": "mult_expr", "symbols": ["pow_expr", "__nl", mod, "__", "mult_expr"], "postprocess": t.binaryOp("mod")},
    {"name": "mult_expr", "symbols": ["pow_expr"], "postprocess": id},
    {"name": "pow_expr", "symbols": ["bit_expr", "__nl", pow, "__", "pow_expr"], "postprocess": t.binaryOp("pow")},
    {"name": "pow_expr", "symbols": [minus, "atomic_value"], "postprocess": t.unaryOp("unary_minus")},
    {"name": "pow_expr", "symbols": [plus, "atomic_value"], "postprocess": t.unaryOp("unary_plus")},
    {"name": "pow_expr", "symbols": ["bit_expr"], "postprocess": id},
    {"name": "bit_expr", "symbols": ["unary_expr", "__nl", bitwise_and, "__", "bit_expr"], "postprocess": t.binaryOp("bitwise_and")},
    {"name": "bit_expr", "symbols": ["unary_expr", "__nl", bitwise_or, "__", "bit_expr"], "postprocess": t.binaryOp("bitwise_or")},
    {"name": "bit_expr", "symbols": ["unary_expr", "__nl", bitwise_xor, "__", "bit_expr"], "postprocess": t.binaryOp("bitwise_xor")},
    {"name": "bit_expr", "symbols": [bitwise_neg, "simple_value"], "postprocess": t.unaryOp("bitwise_neg")},
    {"name": "bit_expr", "symbols": ["unary_expr"], "postprocess": id},
    {"name": "unary_expr", "symbols": [incr, "fully_qualified_name"], "postprocess": t.unaryOp("pre_increment")},
    {"name": "unary_expr", "symbols": [decr, "fully_qualified_name"], "postprocess": t.unaryOp("pre_decrement")},
    {"name": "unary_expr", "symbols": ["fully_qualified_name", incr], "postprocess": t.unaryOpPost("post_increment")},
    {"name": "unary_expr", "symbols": ["fully_qualified_name", decr], "postprocess": t.unaryOpPost("post_decrement")},
    {"name": "unary_expr", "symbols": ["simple_value"], "postprocess": data => ({ type: "sv_unary_expr", data: id(data) })},
    {"name": "logical_expr", "symbols": ["disjonction"], "postprocess": id},
    {"name": "disjonction", "symbols": ["conjonction", "__nl", lor, "__", "disjonction"], "postprocess": t.binaryOp("lor")},
    {"name": "disjonction", "symbols": ["conjonction"], "postprocess": id},
    {"name": "conjonction", "symbols": ["logical_unary__ft", "__nl", land, "__", "conjonction"], "postprocess": t.binaryOp("land")},
    {"name": "conjonction", "symbols": ["logical_unary"], "postprocess": id},
    {"name": "logical_unary", "symbols": [neg, "simple_value"], "postprocess": t.unaryOp("neg")},
    {"name": "logical_unary", "symbols": ["simple_value", "__nl", kWin, "__", "simple_value"], "postprocess": t.binaryOp("in")},
    {"name": "logical_unary", "symbols": ["simple_value", "__nl", eq, "__", "simple_value"], "postprocess": t.binaryOp("eq")},
    {"name": "logical_unary", "symbols": ["simple_value", "__nl", neq, "__", "simple_value"], "postprocess": t.binaryOp("neq")},
    {"name": "logical_unary", "symbols": ["simple_value", "__nl", lt, "__", "simple_value"], "postprocess": t.binaryOp("lt")},
    {"name": "logical_unary", "symbols": ["simple_value", "__nl", gt, "__", "simple_value"], "postprocess": t.binaryOp("gt")},
    {"name": "logical_unary", "symbols": ["simple_value", "__nl", leq, "__", "simple_value"], "postprocess": t.binaryOp("leq")},
    {"name": "logical_unary", "symbols": ["simple_value", "__nl", geq, "__", "simple_value"], "postprocess": t.binaryOp("geq")},
    {"name": "logical_unary__ft", "symbols": ["logical_unary"], "postprocess": id},
    {"name": "logical_unary__ft", "symbols": ["simple_value"], "postprocess": data => ({ type: "sv_logical_unary", data: id(data) })},
    {"name": "spe_expr", "symbols": ["value_expr", "__nl", null_coal, "__", "value_expr"], "postprocess": t.binaryOp("null_coalescing")},
    {"name": "spe_expr", "symbols": ["value_expr", "__nl", question, "__", "value_expr", "__nl", colon, "__", "value_expr"], "postprocess": data => ({ type: "ternary", condition: t.first(data), ifTrue: t.mid(data), ifFalse: t.last(data) })},
    {"name": "operator_name", "symbols": [kWoperator, {"literal":"\""}, "operator", {"literal":"\""}], "postprocess": data => ({ type: "operator_name", operator: t.beforeLast(data) })},
    {"name": "operator", "symbols": [lt], "postprocess": id},
    {"name": "operator", "symbols": [gt], "postprocess": id},
    {"name": "operator", "symbols": [leq], "postprocess": id},
    {"name": "operator", "symbols": [geq], "postprocess": id},
    {"name": "operator", "symbols": [lor], "postprocess": id},
    {"name": "operator", "symbols": [bitwise_or], "postprocess": id},
    {"name": "operator", "symbols": [land], "postprocess": id},
    {"name": "operator", "symbols": [bitwise_and], "postprocess": id},
    {"name": "operator", "symbols": [neg], "postprocess": id},
    {"name": "operator", "symbols": [bitwise_neg], "postprocess": id},
    {"name": "operator", "symbols": [bitwise_xor], "postprocess": id},
    {"name": "operator", "symbols": [plus], "postprocess": id},
    {"name": "operator", "symbols": [minus], "postprocess": id},
    {"name": "operator", "symbols": [times], "postprocess": id},
    {"name": "operator", "symbols": [div], "postprocess": id},
    {"name": "operator", "symbols": [mod], "postprocess": id},
    {"name": "operator", "symbols": [eq], "postprocess": id},
    {"name": "operator", "symbols": [neq], "postprocess": id},
    {"name": "operator", "symbols": [assign], "postprocess": id},
    {"name": "operator", "symbols": [null_coal], "postprocess": id},
    {"name": "operator", "symbols": [plus_eq], "postprocess": id},
    {"name": "operator", "symbols": [minus_eq], "postprocess": id},
    {"name": "operator", "symbols": [times_eq], "postprocess": id},
    {"name": "operator", "symbols": [div_eq], "postprocess": id},
    {"name": "operator", "symbols": [mod_eq], "postprocess": id},
    {"name": "operator", "symbols": [bitwise_and_eq], "postprocess": id},
    {"name": "operator", "symbols": [bitwise_or_eq], "postprocess": id},
    {"name": "operator", "symbols": [bitwise_xor_eq], "postprocess": id},
    {"name": "operator", "symbols": [land_eq], "postprocess": id},
    {"name": "operator", "symbols": [lor_eq], "postprocess": id},
    {"name": "operator", "symbols": [unary_neg_eq], "postprocess": id},
    {"name": "operator", "symbols": [incr], "postprocess": id},
    {"name": "operator", "symbols": [decr], "postprocess": id},
    {"name": "operator", "symbols": [pow], "postprocess": id},
    {"name": "operator", "symbols": [kWin], "postprocess": id},
    {"name": "operator", "symbols": [lparen, rparen], "postprocess": id},
    {"name": "operator", "symbols": [lbracket, rbracket], "postprocess": id},
    {"name": "params", "symbols": [lparen, "_nl", "param_list", "_nl", rparen], "postprocess": t.mid},
    {"name": "params", "symbols": ["ident"], "postprocess": t.id},
    {"name": "lambda", "symbols": ["params", "expression_body"], "postprocess": data => ({ type: "lambda", params: t.first(data), body: t.last(data) })},
    {"name": "anonymous_func", "symbols": ["function_prefix", "params", "expr_block"], "postprocess": data => ({ type: "anonymous_func", params: t.mid(data), body: t.last(data) })},
    {"name": "computed_property", "symbols": ["ident", "computed_body"], "postprocess": data => ({ type: "computed_property", property: t.first(data), body: t.last(data) })},
    {"name": "param_list", "symbols": [], "postprocess": () => ({ type: "param_list", params: [] })},
    {"name": "param_list$ebnf$1$subexpression$1", "symbols": ["_", comma, "_", "ident"]},
    {"name": "param_list$ebnf$1", "symbols": ["param_list$ebnf$1$subexpression$1"]},
    {"name": "param_list$ebnf$1$subexpression$2", "symbols": ["_", comma, "_", "ident"]},
    {"name": "param_list$ebnf$1", "symbols": ["param_list$ebnf$1", "param_list$ebnf$1$subexpression$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "param_list$ebnf$2$subexpression$1", "symbols": ["_", comma, "_"]},
    {"name": "param_list$ebnf$2", "symbols": ["param_list$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "param_list$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "param_list", "symbols": ["ident", "param_list$ebnf$1", "param_list$ebnf$2"], "postprocess": data => ({ type: "param_list", params: [t.first(data), ...t.second(data).map(t.last)] })},
    {"name": "throw_stmt", "symbols": [kWthrow, "__", "value_expr"], "postprocess": data => ({ type: "throw_stmt", exception: t.last(data) })},
    {"name": "return_stmt", "symbols": [kWreturn, "__", "value_expr"], "postprocess": data => ({ type: "return_stmt", value: t.last(data) })},
    {"name": "ifBranch", "symbols": [kWif, "_", lparen, "_nl", "value_expr", "_nl", rparen, "_nl", "expr"], "postprocess": data => ({ type: "if_branch", condition:t.mid(data), body: t.last(data) })},
    {"name": "elseIfBranch", "symbols": [kWelse, "__", "ifBranch"], "postprocess": data => ({ ...t.last(data), type: "else_if_branch" })},
    {"name": "elseBranch", "symbols": [kWelse, "_nl", "expr"], "postprocess": data => ({ ...t.last(data), type: "else_branch" })},
    {"name": "whileBlock", "symbols": [kWwhile, "_", lparen, "_nl", "value_expr", "_nl", rparen], "postprocess": t.afterMid},
    {"name": "if_stmt$ebnf$1", "symbols": []},
    {"name": "if_stmt$ebnf$1$subexpression$1", "symbols": ["elseIfBranch"]},
    {"name": "if_stmt$ebnf$1", "symbols": ["if_stmt$ebnf$1", "if_stmt$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "if_stmt$ebnf$2$subexpression$1", "symbols": ["elseBranch"]},
    {"name": "if_stmt$ebnf$2", "symbols": ["if_stmt$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "if_stmt$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "if_stmt", "symbols": ["ifBranch", "if_stmt$ebnf$1", "if_stmt$ebnf$2"], "postprocess": data => ({ type: "if_stmt", ifBranch: t.first(data), elseIfBranches: t.mid(data).map(id), elseBranch: t.last(data) })},
    {"name": "while_stmt", "symbols": ["whileBlock", "_nl", "expr"], "postprocess": data => ({ type: "while_stmt", condition: t.first(data), body: t.last(data) })},
    {"name": "do_while_stmt", "symbols": [kWdo, "_nl", "expr", "_nl", "whileBlock"], "postprocess": data => ({ type: "do_while_stmt", condition: t.last(data), body: t.mid(data) })},
    {"name": "arrayLiteral", "symbols": [lbracket, "_nl", "arg_list", "_nl", rbracket], "postprocess": data => ({ type: "arrayLiteral", items: t.mid(data) })},
    {"name": "objectLiteral", "symbols": [lcurly, "__nl", rcurly], "postprocess": data => ({ type: "objectLiteral", entries: t.mid(data) })},
    {"name": "nullLiteral", "symbols": [kWnull], "postprocess": id},
    {"name": "destructuring", "symbols": ["array_destructuring"], "postprocess": id},
    {"name": "destructuring", "symbols": ["object_destructuring"], "postprocess": id},
    {"name": "array_destructuring", "symbols": [lbracket, "_", "destructuring_list", "_", rbracket], "postprocess": data => ({ type: "array_destructuring", structure: t.mid(data) })},
    {"name": "object_destructuring", "symbols": [lcurly, "_", "destructuring_list", "_", rcurly], "postprocess": data => ({ type: "object_destructuring", structure: t.mid(data) })},
    {"name": "destructuring_list$ebnf$1", "symbols": []},
    {"name": "destructuring_list$ebnf$1$subexpression$1", "symbols": ["_", comma, "__", "ident"]},
    {"name": "destructuring_list$ebnf$1", "symbols": ["destructuring_list$ebnf$1", "destructuring_list$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "destructuring_list$ebnf$2$subexpression$1", "symbols": ["_", comma, "__"]},
    {"name": "destructuring_list$ebnf$2", "symbols": ["destructuring_list$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "destructuring_list$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "destructuring_list", "symbols": ["ident", "destructuring_list$ebnf$1", "destructuring_list$ebnf$2"], "postprocess": data => ({ type: "destructuring_list", items: [t.first(data), ...t.mid(data).map(t.beforeLast)] })},
    {"name": "match_expr", "symbols": [kWmatch, lparen, "_nl", "value_expr", "_nl", rparen, "matchBody"], "postprocess": data => ({ type: "match_stmt", matched: t.mid(data), body: t.last(data) })},
    {"name": "matchBody$ebnf$1", "symbols": ["matchBranch"]},
    {"name": "matchBody$ebnf$1", "symbols": ["matchBody$ebnf$1", "matchBranch"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "matchBody$ebnf$2", "symbols": ["matchDefaultBranch"], "postprocess": id},
    {"name": "matchBody$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "matchBody", "symbols": [lcurly, "__nl", "matchBody$ebnf$1", "matchBody$ebnf$2", "__nl", rcurly], "postprocess": data => ({ type: "match_body", branches: t.beforeMid(data), defaultBranch: t.afterMid(data) })},
    {"name": "matchDefaultBranch", "symbols": [kW_, "matchBranchBody"], "postprocess": data => ({ type: "match_default_branch", body: t.last(data) })},
    {"name": "matchBranchBody", "symbols": ["__", arrow, "__", "value_expr"], "postprocess": t.last},
    {"name": "matchBranch", "symbols": ["matchStructure", "matchBranchBody", "__nl"], "postprocess": data => ({ type: "match_branch", body: t.mid(data), structure: matchStructure })},
    {"name": "matchStructure", "symbols": ["array_destructuring"], "postprocess": data => ({ type: "destructuring_match", structure: t.first(data) })},
    {"name": "matchStructure", "symbols": ["literal"], "postprocess": data => ({ type: "literal_match", structure: t.first(data) })},
    {"name": "matchStructure", "symbols": ["matchOrIntroduceVariable"], "postprocess": id},
    {"name": "matchStructure$ebnf$1$subexpression$1", "symbols": ["_", comma, "__", "matchStructure"]},
    {"name": "matchStructure$ebnf$1", "symbols": ["matchStructure$ebnf$1$subexpression$1"]},
    {"name": "matchStructure$ebnf$1$subexpression$2", "symbols": ["_", comma, "__", "matchStructure"]},
    {"name": "matchStructure$ebnf$1", "symbols": ["matchStructure$ebnf$1", "matchStructure$ebnf$1$subexpression$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "matchStructure$ebnf$2$subexpression$1", "symbols": ["_", comma, "__"]},
    {"name": "matchStructure$ebnf$2", "symbols": ["matchStructure$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "matchStructure$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "matchStructure", "symbols": ["matchStructure", "matchStructure$ebnf$1", "matchStructure$ebnf$2"], "postprocess": data => ({ type: "choice_match", choices: [t.first(data), ...t.second(data).map(t.last)] })},
    {"name": "matchStructure$ebnf$3$subexpression$1", "symbols": ["_", bitwise_and, "__", "matchStructure"]},
    {"name": "matchStructure$ebnf$3", "symbols": ["matchStructure$ebnf$3$subexpression$1"]},
    {"name": "matchStructure$ebnf$3$subexpression$2", "symbols": ["_", bitwise_and, "__", "matchStructure"]},
    {"name": "matchStructure$ebnf$3", "symbols": ["matchStructure$ebnf$3", "matchStructure$ebnf$3$subexpression$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "matchStructure$ebnf$4$subexpression$1", "symbols": ["_", bitwise_and, "__"]},
    {"name": "matchStructure$ebnf$4", "symbols": ["matchStructure$ebnf$4$subexpression$1"], "postprocess": id},
    {"name": "matchStructure$ebnf$4", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "matchStructure", "symbols": ["matchStructure", "matchStructure$ebnf$3", "matchStructure$ebnf$4"], "postprocess": data => ({ type: "multiple_match", criterias: [t.first(data), ...t.second(data).map(t.last)] })},
    {"name": "matchStructure", "symbols": [lbracket, "_", "matchOrIntroduceVariable", "__", bitwise_or, "__", "matchOrIntroduceVariable", "_", rbracket], "postprocess": data => ({ type: "array_match", head: data[2], tail: data[6] })},
    {"name": "matchVariable", "symbols": [lt, "_", "fully_qualified_name", "_", gt], "postprocess": data => ({ type: "variable_match", ref: t.mid(data) })},
    {"name": "matchOrIntroduceVariable", "symbols": ["matchVariable"], "postprocess": id},
    {"name": "matchOrIntroduceVariable", "symbols": ["ident"], "postprocess": data => ({ type: "introduce_variable_match", variable: t.first(data) })},
    {"name": "file$ebnf$1$subexpression$1", "symbols": ["_nl", "expr"]},
    {"name": "file$ebnf$1", "symbols": ["file$ebnf$1$subexpression$1"]},
    {"name": "file$ebnf$1$subexpression$2", "symbols": ["_nl", "expr"]},
    {"name": "file$ebnf$1", "symbols": ["file$ebnf$1", "file$ebnf$1$subexpression$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "file", "symbols": ["file$ebnf$1", "_nl"], "postprocess": t.mapFirst(t.last)},
    {"name": "_$ebnf$1", "symbols": []},
    {"name": "_$ebnf$1", "symbols": ["_$ebnf$1", WS], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "_", "symbols": ["_$ebnf$1"]},
    {"name": "__$ebnf$1", "symbols": [WS]},
    {"name": "__$ebnf$1", "symbols": ["__$ebnf$1", WS], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "__", "symbols": ["__$ebnf$1"]},
    {"name": "_nl$ebnf$1", "symbols": []},
    {"name": "_nl$ebnf$1$subexpression$1", "symbols": [WS]},
    {"name": "_nl$ebnf$1$subexpression$1", "symbols": [NL]},
    {"name": "_nl$ebnf$1", "symbols": ["_nl$ebnf$1", "_nl$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "_nl", "symbols": ["_nl$ebnf$1"]},
    {"name": "__nl$ebnf$1$subexpression$1", "symbols": [WS]},
    {"name": "__nl$ebnf$1$subexpression$1", "symbols": [NL]},
    {"name": "__nl$ebnf$1", "symbols": ["__nl$ebnf$1$subexpression$1"]},
    {"name": "__nl$ebnf$1$subexpression$2", "symbols": [WS]},
    {"name": "__nl$ebnf$1$subexpression$2", "symbols": [NL]},
    {"name": "__nl$ebnf$1", "symbols": ["__nl$ebnf$1", "__nl$ebnf$1$subexpression$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "__nl", "symbols": ["__nl$ebnf$1"]},
    {"name": "ident", "symbols": [ident], "postprocess": id},
    {"name": "numberLiteral", "symbols": [numberLiteral], "postprocess": id},
    {"name": "stringLiteral", "symbols": [stringLiteral], "postprocess": id},
    {"name": "booleanLiteral$subexpression$1", "symbols": [kWtrue]},
    {"name": "booleanLiteral$subexpression$1", "symbols": [kWfalse]},
    {"name": "booleanLiteral", "symbols": ["booleanLiteral$subexpression$1"], "postprocess": id},
    {"name": "function_prefix$subexpression$1", "symbols": [kWfn]},
    {"name": "function_prefix$subexpression$1", "symbols": [kWfunction]},
    {"name": "function_prefix", "symbols": ["function_prefix$subexpression$1"], "postprocess": id},
    {"name": "functionLiteral", "symbols": ["anonymous_func"]},
    {"name": "functionLiteral", "symbols": ["lambda"], "postprocess": id},
    {"name": "literal", "symbols": ["numberLiteral"], "postprocess": id},
    {"name": "literal", "symbols": ["booleanLiteral"], "postprocess": id},
    {"name": "literal", "symbols": ["stringLiteral"], "postprocess": id},
    {"name": "literal", "symbols": ["nullLiteral"], "postprocess": id},
    {"name": "literal", "symbols": ["functionLiteral"], "postprocess": id},
    {"name": "literal", "symbols": ["arrayLiteral"], "postprocess": id},
    {"name": "literal", "symbols": ["objectLiteral"], "postprocess": id},
    {"name": "fully_qualified_name$ebnf$1", "symbols": []},
    {"name": "fully_qualified_name$ebnf$1$subexpression$1", "symbols": ["ident", ns]},
    {"name": "fully_qualified_name$ebnf$1", "symbols": ["fully_qualified_name$ebnf$1", "fully_qualified_name$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "fully_qualified_name$subexpression$1", "symbols": ["ident"], "postprocess": id},
    {"name": "fully_qualified_name$subexpression$1", "symbols": ["operator_name"], "postprocess": id},
    {"name": "fully_qualified_name", "symbols": ["fully_qualified_name$ebnf$1", "fully_qualified_name$subexpression$1"], "postprocess": data => ({ type: "fqn", path: [...t.mapFirst(t.first)(data), t.last(data)] })},
    {"name": "expr$ebnf$1$subexpression$1", "symbols": ["_", semi]},
    {"name": "expr$ebnf$1", "symbols": ["expr$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "expr$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "expr", "symbols": ["value_expr", "expr$ebnf$1"], "postprocess": id},
    {"name": "expr$ebnf$2$subexpression$1", "symbols": ["_", semi]},
    {"name": "expr$ebnf$2", "symbols": ["expr$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "expr$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "expr", "symbols": ["no_value_expr", "expr$ebnf$2"], "postprocess": id},
    {"name": "value_expr", "symbols": ["operation"], "postprocess": id},
    {"name": "value_expr", "symbols": ["simple_value"], "postprocess": id},
    {"name": "value_expr", "symbols": ["expr_statement"], "postprocess": id},
    {"name": "simple_value", "symbols": ["atomic_value"], "postprocess": id},
    {"name": "simple_value", "symbols": ["paren_expr"], "postprocess": id},
    {"name": "atomic_value", "symbols": ["literal"], "postprocess": id},
    {"name": "atomic_value", "symbols": ["fully_qualified_name"], "postprocess": id},
    {"name": "atomic_value", "symbols": ["func_call"], "postprocess": id},
    {"name": "atomic_value", "symbols": ["ufc"], "postprocess": id},
    {"name": "atomic_value", "symbols": ["method_call"], "postprocess": id},
    {"name": "no_value_expr", "symbols": ["expr_block"], "postprocess": id},
    {"name": "no_value_expr", "symbols": ["statement"], "postprocess": id},
    {"name": "expr_statement", "symbols": ["throw_stmt"], "postprocess": id},
    {"name": "expr_statement", "symbols": ["return_stmt"], "postprocess": id},
    {"name": "statement", "symbols": ["if_stmt"], "postprocess": id},
    {"name": "statement", "symbols": ["while_stmt"], "postprocess": id},
    {"name": "statement", "symbols": ["do_while_stmt"], "postprocess": id},
    {"name": "paren_expr", "symbols": [lparen, "_nl", "value_expr", "_nl", rparen], "postprocess": data => ({ type: "paren_expr", expr: t.mid(data) })},
    {"name": "expr_block$ebnf$1", "symbols": []},
    {"name": "expr_block$ebnf$1$subexpression$1", "symbols": ["expr", "__nl"]},
    {"name": "expr_block$ebnf$1", "symbols": ["expr_block$ebnf$1", "expr_block$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "expr_block", "symbols": [lcurly, "_nl", "expr_block$ebnf$1", rcurly], "postprocess": data => ({ type: "expr_block", exprs: t.beforeLast(data).map(t.first) })},
    {"name": "expression_body", "symbols": ["__", fat_arrow, "_nl", "expr"], "postprocess": data => ({ type: "expression_body", body: t.last(data) })},
    {"name": "computed_body", "symbols": ["__", wavy_arrow, "_nl", "expr"], "postprocess": data => ({ type: "computed_body", body: t.last(data) })}
]
  , ParserStart: "file"
}
if (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {
   module.exports = grammar;
} else {
   window.grammar = grammar;
}
})();
